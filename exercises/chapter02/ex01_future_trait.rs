// Exercise 2.1: Understanding the Future Trait
//
// This exercise helps you understand how the Future trait works internally
// by implementing custom Futures and seeing how polling works.

use futures::task::{Context, Poll, Waker};
use futures::{executor::block_on, Future};
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};

// A simple timer Future that completes after a specified duration
struct TimerFuture {
    shared_state: Arc<Mutex<SharedState>>,
}

struct SharedState {
    completed: bool,
    waker: Option<Waker>,
}

impl TimerFuture {
    pub fn new(duration: Duration) -> Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut state = thread_shared_state.lock().unwrap();
            state.completed = true;
            if let Some(waker) = state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}

// TODO: Implement the Future trait for TimerFuture
impl Future for TimerFuture {
    type Output = ();

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // Your implementation here:
        // 1. Lock the shared_state
        // 2. Check if completed is true - if so, return Poll::Ready(())
        // 3. If not completed, store cx.waker().clone() and return Poll::Pending
        
        todo!("Implement Future::poll for TimerFuture")
    }
}

// A Future that yields a computed value
struct ComputeFuture {
    value: Option<i32>,
    computed: bool,
}

impl ComputeFuture {
    fn new(value: i32) -> Self {
        Self {
            value: Some(value),
            computed: false,
        }
    }
}

// TODO: Implement Future for ComputeFuture
impl Future for ComputeFuture {
    type Output = i32;

    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        // Your implementation here:
        // 1. If already computed, return Poll::Ready with the value
        // 2. If not computed, simulate work, mark as computed, and return the value
        // 3. Use self.value.take().unwrap() to get the value
        
        todo!("Implement Future::poll for ComputeFuture")
    }
}

// TODO: Create a custom Future that combines two other futures
struct JoinFuture<F1, F2>
where
    F1: Future,
    F2: Future,
{
    future1: Option<F1>,
    future2: Option<F2>,
    output1: Option<F1::Output>,
    output2: Option<F2::Output>,
}

impl<F1, F2> JoinFuture<F1, F2>
where
    F1: Future,
    F2: Future,
{
    fn new(future1: F1, future2: F2) -> Self {
        Self {
            future1: Some(future1),
            future2: Some(future2),
            output1: None,
            output2: None,
        }
    }
}

// TODO: Implement Future for JoinFuture
impl<F1, F2> Future for JoinFuture<F1, F2>
where
    F1: Future,
    F2: Future,
{
    type Output = (F1::Output, F2::Output);

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // Your implementation here:
        // This is advanced! For now, just return Poll::Pending
        // The full implementation requires unsafe code for Pin projections
        
        todo!("Implement Future::poll for JoinFuture - this is challenging!")
    }
}

#[tokio::main]
async fn main() {
    println!("🚀 Welcome to Async Exercise 2.1!");
    println!("📖 Understanding the Future trait\n");
    
    println!("=== ⏰ Testing TimerFuture ===");
    let start = Instant::now();
    
    block_on(TimerFuture::new(Duration::from_millis(500)));
    
    println!("✅ TimerFuture completed in: {:?}\n", start.elapsed());

    println!("=== 🧮 Testing ComputeFuture ===");
    let compute_future = ComputeFuture::new(42);
    let result = block_on(compute_future);
    println!("✅ ComputeFuture result: {}\n", result);

    println!("=== 🔗 Testing JoinFuture ===");
    let timer1 = TimerFuture::new(Duration::from_millis(200));
    let timer2 = TimerFuture::new(Duration::from_millis(300));
    let join_future = JoinFuture::new(timer1, timer2);
    
    let start = Instant::now();
    block_on(join_future);
    println!("✅ JoinFuture completed in: {:?}", start.elapsed());

    println!("\n💡 Key concepts:");
    println!("   • Future trait and polling model");
    println!("   • Waker mechanism for efficient scheduling");
    println!("   • State machines generated by async/await");
    println!("   • Pin and self-referential futures");
    
    println!("\n🤔 Think about:");
    println!("   • Why do we need to store the Waker?");
    println!("   • What happens if we don't call wake()?");
    println!("   • How does Pin help with memory safety?");
    
    println!("\n✅ Run 'cargo run --bin run -- check 2.1' to verify your solution!");
}

// ==================== TESTS ====================
#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Instant;
    
    #[test]
    fn test_timer_future_completes() {
        let start = Instant::now();
        let timer = TimerFuture::new(Duration::from_millis(100));
        block_on(timer);
        let duration = start.elapsed();
        
        assert!(duration >= Duration::from_millis(90), 
            "Timer should wait approximately the specified duration");
        assert!(duration < Duration::from_millis(200), 
            "Timer should not take too long");
    }
    
    #[test]
    fn test_compute_future_returns_value() {
        let compute = ComputeFuture::new(123);
        let result = block_on(compute);
        assert_eq!(result, 123, "ComputeFuture should return the input value");
    }
    
    #[test] 
    fn test_compute_future_simulates_work() {
        let start = Instant::now();
        let compute = ComputeFuture::new(42);
        block_on(compute);
        let duration = start.elapsed();
        
        // Should simulate some work (but this test is flexible)
        assert!(duration < Duration::from_millis(500), 
            "ComputeFuture shouldn't take too long");
    }
    
    #[test]
    fn test_no_todos_remaining() {
        let source = include_str!("ex01_future_trait.rs");
        let todo_count = source.matches("todo!").count();
        
        assert_eq!(todo_count, 0, 
            "Remove all todo!() macros and implement the required functions");
    }
}